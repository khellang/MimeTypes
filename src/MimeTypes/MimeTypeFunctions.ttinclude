<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ assembly name="$(PkgNewtonsoft_Json)\lib\net45\Newtonsoft.Json.dll" #>
<#@ assembly name="System.Core" #>
<#+
    private class MimeType
    {
        public MimeType()
        {
            Extensions = new List<string>();
        }

        public string Source { get; set; }

        public List<string> Extensions { get; }

        public bool Compressible { get; set; }

        public string Charset { get; set; }
    }

    private class Mapping
    {
        public Mapping(string mimeType, string source, string extension)
        {
            MimeType = mimeType;
            Source = source ?? "custom";
            Extension = extension;
        }

        public string MimeType { get; set; }

        public string Source { get; set; }

        public string Extension { get; set; }
    }

    private class SourceComparer : IComparer<string>
    {
        public static readonly SourceComparer Instance = new();

        public int Compare(string x, string y)
        {
            if (string.Equals(x, y))
            {
                return 0;
            }

            if (x == "custom")
            {
                return 2;
            }

            if (x == "iana")
            {
                return 1;
            }

            return 0;
        }
    }

    private static IList<Mapping> GetMediaTypeList()
    {
        using var client = new WebClient();

        var json = client.DownloadString(new Uri("https://cdn.jsdelivr.net/gh/jshttp/mime-db@master/db.json"));

        var mimeTypes = JsonConvert.DeserializeObject<Dictionary<string, MimeType>>(json);

        return GetMediaTypes(mimeTypes).ToList();
    }

    private static IList<Mapping> GetMediaTypes(IEnumerable<KeyValuePair<string, MimeType>> mimeTypes)
        => mimeTypes
            .SelectMany(x => x.Value.Extensions.Select(e => new Mapping(x.Key, x.Value.Source, e)))
            .Where(x => x.Extension.Length <= 8 && x.Extension.All(char.IsLetterOrDigit))
            .GroupBy(x => x.Extension)
            .Select(GetExtension)
            .OrderBy(x => x.Extension, StringComparer.InvariantCulture)
            .ToList();

    private static readonly Dictionary<string, string> Overrides = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
    {
        { "js", "application/javascript" },
        { "xml", "application/xml" },
    };

    private static Mapping GetExtension(IGrouping<string, Mapping> mappings)
    {
        if (Overrides.TryGetValue(mappings.Key, out var @override))
        {
            return new Mapping(@override, "override", mappings.Key);
        }

        // Prefer custom and IANA sources, then shorter mime types over longer ones
        return mappings
            .OrderByDescending(x => x.Source, SourceComparer.Instance)
            .ThenBy(x => x.MimeType.Length)
            .First();
    }

    public void GenerateClass(bool nullability)
    {
#>
// <auto-generated />

<#+ if (nullability) { #>
#nullable enable
<#+ } #>
#pragma warning disable

namespace $rootnamespace$
{
    using global::System;
    using global::System.Linq;
    using global::System.Collections.Generic;
    using global::System.Diagnostics;
<#+ if (nullability) { #>
    using global::System.Diagnostics.CodeAnalysis;
<#+ } #>
    using global::System.Runtime.CompilerServices;

    /// <summary>
    /// Provides utilities for mapping file names and extensions to MIME-types.
    /// </summary>
    [CompilerGenerated]
    [DebuggerNonUserCode]
    public static class MimeTypes
    {
        private const string DefaultFallbackMimeType = "application/octet-stream";
        private static string s_fallbackMimeType;

        /// <summary>
        /// The fallback MIME-type. Defaults to <c>application/octet-stream</c>.
        /// </summary>
<#+ if (nullability) { #>
        [AllowNull]
<#+ } #>
        public static string FallbackMimeType
        {
            get => s_fallbackMimeType;
            set => s_fallbackMimeType = value ?? DefaultFallbackMimeType;
        }

        private static readonly Dictionary<string, string> s_typeMap;

        static MimeTypes()
        {
            s_fallbackMimeType = DefaultFallbackMimeType;

<#+
    var mediaTypes = GetMediaTypeList();
    var mediaTypesCount = mediaTypes.Count.ToString(System.Globalization.CultureInfo.InvariantCulture);
#>
            s_typeMap = new Dictionary<string, string>(<#= mediaTypesCount #>, StringComparer.OrdinalIgnoreCase)
            {
        <#+ foreach (var mediaType in mediaTypes) { #>
        { "<#= mediaType.Extension #>", "<#= mediaType.MimeType #>" },
        <#+ } #>
    };
        }

        /// <summary>
        /// Attempts to fetch all available file extensions for a MIME-type.
        /// </summary>
        /// <param name="mimeType">The name of the MIME-type</param>
        /// <returns>All available extensions for the given MIME-type</returns>
        public static IEnumerable<string> GetMimeTypeExtensions(string mimeType)
        {
            if (mimeType is null)
            {
                throw new ArgumentNullException(nameof(mimeType));
            }

            return s_typeMap
                .Where(keyPair => string.Equals(keyPair.Value, mimeType, StringComparison.OrdinalIgnoreCase))
                .Select(keyPair => keyPair.Key);
        }

        /// <summary>
        /// Attempts to validate MIME-type.
        /// </summary>
        /// <param name="mimeType">The name of the MIME-type</param>
        /// <returns><c>true</c> if a MIME-type was found, <c>false</c> otherwise</returns>
        public static bool IsValidMimeType(string mimeType)
        {
            if (mimeType is null)
            {
                throw new ArgumentNullException(nameof(mimeType));
            }

            return s_typeMap
                .Any(keyPair => string.Equals(keyPair.Value, mimeType, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Tries to get the MIME-type for the given file name.
        /// </summary>
        /// <param name="fileName">The name of the file.</param>
        /// <param name="mimeType">The MIME-type for the given file name.</param>
        /// <returns><c>true</c> if a MIME-type was found, <c>false</c> otherwise.</returns>
<#+ if (nullability) { #>
        public static bool TryGetMimeType(string? fileName, [NotNullWhen(true)] out string? mimeType)
<#+ } else { #>
        public static bool TryGetMimeType(string fileName, out string mimeType)
<#+ } #>
        {
            if (fileName is null)
            {
                mimeType = null;
                return false;
            }

            var dotIndex = fileName.LastIndexOf('.');

            if (dotIndex != -1 && fileName.Length > dotIndex + 1)
            {
                return s_typeMap.TryGetValue(fileName.Substring(dotIndex + 1), out mimeType);
            }

            mimeType = null;
            return false;
        }

        /// <summary>
        /// Gets the MIME-type for the given file name,
        /// or <see cref="FallbackMimeType"/> if a mapping doesn't exist.
        /// </summary>
        /// <param name="fileName">The name of the file.</param>
        /// <returns>The MIME-type for the given file name.</returns>
        public static string GetMimeType(string fileName)
        {
            if (fileName is null)
            {
                throw new ArgumentNullException(nameof(fileName));
            }

            return TryGetMimeType(fileName, out var result) ? result : FallbackMimeType;
        }
    }
}

#pragma warning enable
<#+
    }
#>